use std::future::Future;
use std::pin::Pin;
use std::sync::Arc;
use std::task::{Context, Poll, Waker};
use std::sync::Mutex;

use futures_core::FusedFuture;

/// Returns a new [Completable](self::Completable) future and its associated
/// [CompletionHandle](self::CompletionHandle). Further handles can be generated by
/// [cloning](std::clone::Clone::clone()) the initial handle.
///
/// # Example
///
/// ```
/// # futures::executor::block_on(async {
/// use futures::future;
///
/// let (handle, future) = future::completable();
///
/// // This thread is an example of how some other process can complete the future via
/// // its handle.
/// let thread = std::thread::spawn(|| {
///    handle.complete(123);
/// });
///
/// assert_eq!(future.await, Some(123));
/// thread.join().unwrap();
/// # });
/// ```
pub fn completable<T>() -> (CompletionHandle<T>, Completable<T>) {
    let state = Arc::new(Mutex::new(Some(State::PendingCompletion {
        handle_count: 1,
        waker: None
    })));
    (CompletionHandle(state.clone()), Completable(state))
}

/// A handle associated with a [Completable](self::Completable) future that can be used
/// to manually complete the future. Multiple handles to the same future can exist, and
/// only the first call to [complete](self::CompletionHandle::complete()) will result in
/// the future completing.
// Implementation note: this struct wraps an Arc rather than a Weak because I couldn't get
// the Weak to work properly. However, the overall effect is still that handles act as
// weak references to the Completable due to the handle_count field inside the state.
#[derive(Debug)]
pub struct CompletionHandle<T>(Arc<Mutex<Option<State<T>>>>);

impl<T> CompletionHandle<T> {
    /// Complete the associated [Completable](self::Completable) future if it is not
    /// already completed. Returns `true` if the future transitioned to complete as a
    /// result of this call, or `false` if the future had already been completed by
    /// another call. In the case of `false`, the `value` provided to this call is
    /// immediately dropped.
    pub fn complete(self, value: T) -> bool {
        let mut state = self.0.lock().expect("Mutex lock failed");
        let (next_state, did_complete) = match state.take().expect("State should be present") {
            State::PendingCompletion { handle_count, mut waker } => {
                debug_assert!(handle_count >= 1);
                if let Some(waker) = waker.take() {
                    waker.wake();
                }
                (State::Ready(value), true)
            },
            otherwise => (otherwise, false)
        };
        *state = Some(next_state);
        did_complete
    }
}

impl<T> Drop for CompletionHandle<T> {
    fn drop(&mut self) {
        let mut state = self.0.lock().expect("Mutex lock failed");
        *state = Some(match state.take().expect("State should be present") {
            State::PendingCompletion { handle_count, waker } => {
                debug_assert!(handle_count >= 1);
                if handle_count == 1 {
                    // If this is the last handle and Future::poll has been called, then
                    // let the executor know to poll again.
                    if let Some(waker) = waker {
                        waker.wake();
                    }
                    State::Done
                } else {
                    State::PendingCompletion {
                        handle_count: handle_count - 1,
                        waker
                    }
                }
            },
            otherwise_unchanged => otherwise_unchanged
        });
    }
}

/// Multiple handles to a single [Completable](self::Completable) can be generated by
/// cloning the initial handle.
impl<T> Clone for CompletionHandle<T> {
    fn clone(&self) -> Self {
        // We cannot do a simple #[derive(Clone)] because we need to update the handle_count.
        let mut state = self.0.lock().expect("Mutex lock failed");
        *state = Some(match state.take().expect("State should be present") {
            State::PendingCompletion { handle_count, waker } => {
                debug_assert!(handle_count >= 1);
                State::PendingCompletion {
                    handle_count: handle_count + 1,
                    waker
                }
            },
            otherwise_unchanged => otherwise_unchanged
        });
        std::mem::drop(state);
        CompletionHandle(self.0.clone())
    }
}

/// A [Future](std::future::Future) which must be remotely completed using a
/// [CompletionHandle](self::CompletionHandle).
///
/// # Future behavior
/// * Output type is [`Option<T>`](std::option::Option).
/// * If all handles are dropped without [complete](self::CompletionHandle::complete())
/// having been called on any of them, then the future will resolve to a value of `None`.
/// * If [complete](self::CompletionHandle::complete()) is called with a given value `x`,
/// then the future will resolve with a value of `Some(x)`.
/// * If [complete](self::CompletionHandle::complete()) is called multiple times, only the
/// first time will determine the value the future resolves to. All subsequent calls
/// will be ignored.
/// * This future's behavior is to return `Poll::Ready(None)` in the case that
/// [poll](std::future::Future::poll()) is (improperly) called again after the first
/// time `Poll::Ready` is returned.
///
/// # Drop behavior
/// If the future has taken ownership of a value through `complete` being called on a
/// handle, then the lifetime of the owned value will last no longer than the lifetime of
/// the future itself. In particular, the lifetime of the handles themselves do not. This
/// means that if the [Completable](self::Completable) itself is dropped then the value is
/// guaranteed to have been dropped as well, even if there are still live handles.
#[derive(Debug)]
#[must_use = "futures do nothing unless you `.await` or poll them"]
pub struct Completable<T>(Arc<Mutex<Option<State<T>>>>);

impl<T> Future for Completable<T> {
    type Output = Option<T>;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<T>> {
        let mut state = self.0.lock().expect("Mutex lock failed");
        // The Option around State<T> here is used to take ownership of the completion_value
        // in the State::Ready(T) case.
        let (next_state, result) = match state.take().expect("State should be present") {
            State::PendingCompletion { handle_count, waker: _ } => {
                if handle_count == 0 {
                    // All handles were dropped without a completion value. We'll return
                    // Poll::Ready(None) forever.
                    (State::Done, Poll::Ready(None))
                } else {
                    (State::PendingCompletion {
                        handle_count: handle_count,
                        waker: Some(cx.waker().clone())
                    }, Poll::Pending)
                }
            },
            State::Ready(completion_value) => {
                (State::Done, Poll::Ready(Some(completion_value)))
            },
            State::Done => {
                (State::Done, Poll::Ready(None))
            }
        };
        state.replace(next_state);
        result
    }
}

impl<T> FusedFuture for Completable<T> {
    fn is_terminated(&self) -> bool {
        match self.0.lock().expect("Mutex lock failed").as_ref().expect("State should be present") {
            State::PendingCompletion { handle_count, waker: _ } => handle_count == &0,
            State::Ready(_) => false,
            State::Done => true
        }
    }
}

impl<T> Drop for Completable<T> {
    fn drop(&mut self) {
        let mut state = self.0.lock().expect("Mutex lock failed");
        // This just ensures that the completion_value, if any, is dropped as soon as the
        // future itself is dropped, rather than waiting for all the handles to drop.
        state.replace(State::Done);
    }
}

#[derive(Debug)]
enum State<T> {
    // The initial state. Whether or not the `waker` field is Some or None depends on
    // whether Future::poll has been called (Some) or not (None).
    PendingCompletion {
        handle_count: usize,
        waker: Option<Waker>
    },
    // The future was manually completed by a call to CompletionHandle::complete. The
    // executor may or may not have notified of the completion. On the next call to
    // Future::poll, the future will complete with a Some(T) value.
    Ready(T),
    // The future returned Poll::Ready from a Future::poll call and is now done.
    // If Future:poll is called again, it will return Poll::Ready(None) forever.
    Done
}

#[cfg(test)]
mod completable_tests {
    use super::*;
    use crate::test_support::{unwakeable_poll, InertExecutor};
    use std::sync::atomic::{AtomicBool, Ordering};

    #[test]
    fn is_send_sync() {
        fn t_is_send_sync<T: Send + Sync>() -> bool { true }
        assert!(t_is_send_sync::<CompletionHandle<()>>());
        assert!(t_is_send_sync::<Completable<()>>());
    }

    #[test]
    fn handle_is_clone() {
        fn t_is_clone<T: Clone>() -> bool { true }
        assert!(t_is_clone::<CompletionHandle<()>>());
    }

    #[test]
    fn can_complete_before_first_poll() {
        let exec = InertExecutor::new();
        let (handle, future) = completable::<usize>();
        let task = exec.spawn(future);
        handle.complete(123);
        assert_eq!(exec.poll_one(&task), Poll::Ready(Some(123)));
    }

    #[test]
    fn can_complete_after_first_poll() {
        let exec = InertExecutor::new();
        let (handle, future) = completable::<usize>();
        let task = exec.spawn(future);
        assert_eq!(exec.poll_one(&task), Poll::Pending);
        handle.complete(123);
        assert_eq!(exec.poll_one(&task), Poll::Ready(Some(123)));
    }

    #[test]
    fn can_complete_after_multiple_polls() {
        let exec = InertExecutor::new();
        let (handle, future) = completable::<usize>();
        let task = exec.spawn(future);
        assert_eq!(exec.poll_one(&task), Poll::Pending);
        assert_eq!(exec.poll_one(&task), Poll::Pending);
        assert_eq!(exec.poll_one(&task), Poll::Pending);
        handle.complete(123);
        assert_eq!(exec.poll_one(&task), Poll::Ready(Some(123)));
    }

    #[test]
    fn repeated_polls_return_none() {
        let exec = InertExecutor::new();
        let (handle, future) = completable::<usize>();
        let task = exec.spawn(future);
        assert_eq!(exec.poll_one(&task), Poll::Pending);
        handle.complete(123);
        assert_eq!(exec.poll_one(&task), Poll::Ready(Some(123)));
        assert_eq!(exec.poll_one(&task), Poll::Ready(None));
        assert_eq!(exec.poll_one(&task), Poll::Ready(None));
        assert_eq!(exec.poll_one(&task), Poll::Ready(None));
    }

    #[test]
    fn future_not_woken_if_all_handles_dropped_before_poll() {
        let exec = InertExecutor::new();
        let (handle, future) = completable::<usize>();
        let task = exec.spawn(future);
        assert_eq!(exec.wake_count(&task), 0);
        let handle2 = handle.clone();
        std::mem::drop(handle);
        std::mem::drop(handle2);
        assert_eq!(exec.wake_count(&task), 0);
    }

    #[test]
    fn future_woken_if_all_handles_dropped_after_poll() {
        let exec = InertExecutor::new();
        let (handle, future) = completable::<usize>();
        let task = exec.spawn(future);
        let _ = exec.poll_one(&task);
        assert_eq!(exec.wake_count(&task), 0);
        let handle2 = handle.clone();
        std::mem::drop(handle);
        std::mem::drop(handle2);
        assert_eq!(exec.wake_count(&task), 1);
    }

    #[test]
    fn completion_value_dropped_when_future_dropped_even_if_handles_remain_alive() {
        struct OnDrop<F: FnOnce()>(Option<F>);
        impl<F: FnOnce()> Drop for OnDrop<F> {
            fn drop(&mut self) {
                self.0.take().unwrap()();
            }
        }
        let dropped = AtomicBool::new(false);
        let on_drop = OnDrop(Some(|| dropped.store(true, Ordering::SeqCst)));
        let (handle, future) = completable();
        assert!(!dropped.load(Ordering::SeqCst));
        handle.clone().complete(on_drop);
        std::mem::drop(future);
        assert!(dropped.load(Ordering::SeqCst));
    }

    #[test]
    fn debug() {
        let (handle, future) = completable::<bool>();
        let handle2 = handle.clone();
        assert_eq!(&format!("{:?}", future), "Completable(Mutex { data: Some(PendingCompletion { handle_count: 2, waker: None }) })");
        assert_eq!(&format!("{:?}", handle), "CompletionHandle(Mutex { data: Some(PendingCompletion { handle_count: 2, waker: None }) })");
        handle2.complete(true);
        assert_eq!(&format!("{:?}", future), "Completable(Mutex { data: Some(Ready(true)) })");
        assert_eq!(&format!("{:?}", handle), "CompletionHandle(Mutex { data: Some(Ready(true)) })");
    }

    #[test]
    fn multiply_completed_future_resolves_to_first() {
        let exec = InertExecutor::new();
        let (handle, future) = completable();
        let task = exec.spawn(future);
        assert_eq!(Poll::Pending, exec.poll_one(&task));
        let handle2 = handle.clone();
        let handle3 = handle.clone();
        handle.complete(1);
        handle2.complete(2);
        handle3.complete(3);
        assert_eq!(Poll::Ready(Some(1)), exec.poll_one(&task));
    }

    #[test]
    fn fused_after_completion() {
        let (handle, mut future) = completable();
        assert_eq!(Poll::Pending, unwakeable_poll(&mut future));
        assert!(!future.is_terminated());
        handle.complete(123);
        assert!(!future.is_terminated());
        assert_eq!(Poll::Ready(Some(123)), unwakeable_poll(&mut future));
        assert!(future.is_terminated());
        assert_eq!(Poll::Ready(None), unwakeable_poll(&mut future));
        assert!(future.is_terminated());
    }

    #[test]
    fn fused_when_all_handles_drop_before_completion() {
        let (handle, mut future) = completable::<()>();
        assert_eq!(Poll::Pending, unwakeable_poll(&mut future));
        assert!(!future.is_terminated());
        std::mem::drop(handle);
        assert!(future.is_terminated());
        assert_eq!(Poll::Ready(None), unwakeable_poll(&mut future));
    }
}